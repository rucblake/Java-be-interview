# 学习

## 语言

### 字符串

String、StringBuffer与StringBuilder

### 集合

#### ArrayList

ArrayList是一个动态数组，容量能够自动增长。ArrayList**不是线程安全**的，线程安全的AL可以通过`Collections.synchronizedList(List l)`获取
支持序列化`write/readObj()`、支持下标`get()`访问、支持克隆

ArrayList包含两个私有属性：elementData和size，分别存储当前包含的元素和元素数量。无参数创建时默认大小为10
插入新元素时，size+1，如果size超过当前数组大小，则动态扩容`ensureCapacity`。申请一个新的数组，大小为1.5倍，并将旧的数组复制到新的数组。旧的数组在调用`Arrays.copyOf()`进行复制前，会通过`Object oldData[] = elementData;`进行一次引用，保证copy过程的安全。拷贝使用`System.arraycopy()`方法，底层使用C语言实现，效率更高。

#### LinkedList

LinkedList是一个双向链表，对于插入和删除频繁的list，使用LinkedList会优于ArrayList。LinkedList**不是线程安全**的
LinkedList包括三个成员变量：头结点`first`，尾结点`last`，容量`size`。每一个结点也都是双向结点，包括`prev`和`next`。链表的插入删除时间复杂度都为O(1)。下标查询方式为从头/从尾遍历。占用内存更大。

#### HashMap

[HashMap详解](https://blog.csdn.net/woshimaxiao1/article/details/83661464)

HashMap基于数组+链表实现，解决哈希冲突的方法是链地址法。HashMap不是线程安全的。
HashMap的Entry数据结构包括四个属性：key，value，next（存储下一个entry），hash（key计算出的哈希值）。
哈希表本身还包括几个重要属性：size（实际存储的kv数量），threshold（阈值，默认16），loadFactor（负载因子，默认0.75），modCount（哈希表被改变的次数）

扩容操作：当插入元素后size大于阈值的时候，新建一个大小为双倍的数组，并将目前已有的数据都拷贝过去
插入操作：根据key计算出哈希code：h，然后index = h&(length-1)。因为哈希表的length固定为2的n次幂，因此-1后高位为0，其余为1，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)
查询操作：根据key获取具体的index，找到对应数组下标，判断是否是链表，如果是链表则遍历，直到找到**hash值相同的并且key**相同的entry，然后输出。

JDK1.8对HashMap进行了优化，把链表换成了红黑树，能够保证更快的检索速度。（链表节点大于等于8且数组长度大于等于64）

如果需要线程安全的HashMap，可以使用ConcurrentHashMap（Hashtable也是线程安全的，但是是遗留类，不建议使用）ConcurrentHashMap内部封装了多个HashMap，可以分段加锁而不影响效率。
>不建议使用Hashtable是因为：synchronized会造成线程饥饿和死锁，且进行遍历时其他线程也能对其进行put等操作

### IO

javaIO框架把不同的输入、输出源抽象称作stream，即“流”。通过抽象，代码能够统一对流进行数据处理，而不必关心具体的输入输出形式。

#### 字节流与字符流

底层设备永远是通过字节流传输。字符流是对字节流的包装，直接接收字符串，方便处理。

#### AIO/BIO/NIO

- BIO（同步阻塞I/O模式）
  数据的读取写入必须阻塞在一个线程内等待其完成。
  直到水烧开以前不做任何别的事。

- NIO（同步非阻塞I/O模型）
  使用一个线程去轮询IO操作，发现改变后及时处理。
  有一个线程单独监控水的状态，一旦烧开则通知

- AIO（异步非阻塞I/O模型）
  异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。
  每一个水壶都装了开关，水烧开了开关自动通知
  
### 多线程

多线程的好处:

1. 提高CPU的利用率。从磁盘上读取文件的时候，大多数的CPU时间都会花费在等待磁盘来读取数据。在这个时候CPU是相当空闲的。在这个时候它可以干点别的事情。通过改变操作的顺序，CPU可以得到更好的利用。
2. 防止阻塞主线程,提高吞吐量。使用线程可以把占据时间长的程序中的任务放到后台去处理
3. 程序的运行效率可能会提高，提升程序的响应速度。

```java
Thread t = new Thread();
t.start()
```

通过extends实现自己的线程，通过`start()`方法启动线程，会执行线程内部实现的`run()`方法
线程执行是无序不等待的，可以通过`join()`方法等待线程执行完毕
通过`synchronized`获取锁
通过`this.wait()`等待，必须在`synchronized`内部才能调用

#### synchronized

#### volatile

[volatile详解](https://www.cnblogs.com/wangwudi/p/12303772.html)
多线程执行时，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。而将工作内存的变量写回主内存的时机则不确定。对于volatile修饰的变量，java虚拟机有特殊的约定：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。

volatile针对变量，而Synchronized针对对象和类

#### 乐观锁和悲观锁

乐观锁：读的时候允许写锁后入，导致读的数据可能是不一致的（例如获取锁以后，读取某x的值，但是此时另一个线程获取了写锁，改写了x的值，此时x的值已被更改）
悲观锁：读的过程不允许写，必须等待。
乐观锁的并发效率更高，但是需要有检测机制，检查乐观读锁后是否有新的写锁，如果有，则需要加悲观锁进行读（避免再次被修改）

### JVM内存模型

### 垃圾回收机制

### Maven

## 数据结构

线性数据结构：数组、链表、栈、队列

### 二叉树

树是一种常见的数据结构，所有结点的度均不超过2的有序树为二叉树。二叉树是一种最简单且最重要的树，所有的树都能转化为二叉树。
[二叉树介绍](https://www.jianshu.com/p/bf73c8d50dc2)

#### 二叉树的遍历

通常使用递归调用的方法进行二叉树的遍历，并根据递归的输出顺序，可以简单地分为：前序遍历，中序遍历，后序遍历。

- 前序遍历
从二叉树的根结点出发，当第一次到达结点时就输出结点数据。按照先左后右的顺序，只要能向左前进，就一直向左，否则返回上层，向右前进，而后继续尝试向左。如果右侧也为叶子结点，则返回上层。
技巧：按照遍历顺序输出
遍历代码：

```java
/*前序遍历*/
void PreOrderTraverse(BiTree T)
{
    if(T == NULL) {
        return;
    }
    System.out.println("%c", T.data);  /*先输出*/
    PreOrderTraverse(T.lchild);    /*再遍历左*/
    PreOrderTraverse(T.rchild);    /*最后遍历右*/
}
```

>对于二叉树来说，前序遍历即深度优先搜索

- 中序遍历
从二叉树的根结点出发，当第二次到达结点时就输出结点数据。按照先左后右的顺序，先向左前进，如果前进后为空（即原结点为叶子结点）则返回原结点，此时第二次访问，输出。后续继续向右前进
技巧：对于每一个子树，输出顺序均为左中右
遍历代码：

```java
/*中序遍历*/
void InOrderTraverse(BiTree T)
{
    if(T == NULL) {
        return;
    }
    InOrderTraverse(T.lchild);    /*先遍历左*/
    System.out.println("%c", T.data);  /*再输出*/
    InOrderTraverse(T.rchild);    /*最后遍历右*/
}
```

- 后序遍历
从二叉树的根结点出发，当第三次到达结点时就输出结点数据。按照先左后右的顺序，先向左前进，如果前进后为空（即原结点为叶子结点）则返回原结点，再向右侧出发，如果前进后为空，则返回原结点，此时第三次访问，输出。
技巧：对于每一个子树，输出顺序均为左右中
遍历代码：

```java
/*后序遍历*/
void PostOrderTraverse(BiTree T)
{
    if(T == NULL) {
        return;
    }
    PostOrderTraverse(T.lchild);    /*先遍历左*/
    PostOrderTraverse(T.rchild);    /*后遍历右*/
    System.out.println("%c", T.data);  /*最后输出*/
}
```

- **重点考点：根据前序遍历/后序遍历和中序遍历顺序，确定一颗二叉树**
首先根据前序/后续遍历获取根节点：前序遍历的第一个结点和后序遍历的最后一个结点，都必定是根节点。
然后根据根结点，从中序遍历中获取左子树和右子树：位于中序遍历中根结点前的均为左子树，根结点后的均为右子树。
重复上述过程，继续对子树进行分析，即可得到结果

- 层次遍历
从二叉树的根结点出发，按照从上到下，从左到右的方式依次进行输出，为层次遍历

>对于二叉树来说，层次遍历即为广度优先搜索

### 红黑树

[红黑树介绍](https://zhuanlan.zhihu.com/p/79980618)
[红黑树介绍](https://tech.meituan.com/2016/12/02/redblack-tree.html)

红黑树是一种平衡二叉查找树。二叉查找树是一种左子节点的值比父节点的值要小，右节点的值要比父节点的值大的二叉树。

红黑树定义如下：

1. 任何一个节点都有颜色，黑色或者红色。
2. 根节点是黑色的。
3. 父子节点之间不能出现两个连续的红节点。
4. 任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。
5. 空节点被认为是黑色的。

如果父节点和新节点为红色，则按照以下规则进行修复：
左左：提绳法，提起父节点并变色
左右：旋转新节点，然后复用左左
右右：提起父节点并变色
右左：旋转新节点，然后复用右右

## 操作系统

### 基础

操作系统本质是一个运行在计算机上的软件，它屏蔽了硬件的复杂性，统一进行管理。

- 内核

操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。
操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。

- 系统调用

根据进程访问资源的权限，可以分为用户态和系统态。用户态的进程只能读取用户内存中的数据，涉及到系统级别的资源访问（设备管理，文件管理，进程控制，进程通信，内存管理），需要向操作系统发出请求（系统调用），由操作系统代为完成。

### 进程

- 进程的状态转换

[操作系统之进程的状态和转换详解](https://blog.csdn.net/qwe6112071/article/details/70473905)

通常将进程分为五个状态：

1. 创建状态(new) ：进程正在被创建，尚未到就绪状态。
2. 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
3. 运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
4. 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
5. 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

- 进程 vs 线程

线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。

和多线程相比，多进程的缺点在于：
创建进程比创建线程开销大，尤其是在Windows系统上；
进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：
多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

- 进程通信

常用的方法：

1. 管道：父子进程/兄弟进程之间通信
2. 信号量：多个进程对于共享数据访问，通过信号量达到同步的目的，避免竞争
3. 消息队列：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。
4. 共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。（需要注意上锁）
5. 套接字：常见的TCP/IP通信

- 进程的调度算法

1. 先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
2. 短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
3. 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
4. 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。
5. 优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

### 内存

- 内存管理

包括内存的分配、回收等，常见的管理方式包括：

1. 页式管理
   把主存分为大小相等且固定的一页一页的形式进行管理，提高利用率，降低碎片
2. 段式管理
   页式无实际意义，而段式有。段式更小，例如程序段，数据段，栈段
3. 段页式管理
   结合了段式和页式，把主存先分成若干段，每个段又分成若干页。段与段之间以及段的内部的都是离散的。

快表：当拿到一个页号要寻找对应的物理地址时，先查快表（类似缓存），快表没有再查页表。快表将满时则进行淘汰。

分段和分页的共同点与区别：

1. 共同点：都是为了提高内存利用率，减少碎片。都是离散存储，内部连续。
2. 区别：页的大小固定，由操作系统决定。段的大小不固定，由程序决定。分段是带有逻辑信息的，例如代码段，数据段。

逻辑地址和物理地址：通常编程只关心逻辑地址，例如指针中存储的数值就是逻辑地址。物理地址是内存真正的地址。
>如果没有逻辑地址，直接操作物理地址，会造成数据混乱。例如两个程序同时修改物理地址为1的数据。因此使用虚拟地址进行隔离。

- 虚拟内存

虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。它定义了一个连续的虚拟地址空间，并且**把内存扩展到硬盘**空间。

- 局部性原理

1. 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
2. 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

- 页面置换算法

当发生缺页中断，即内存中不存在所需要的页，需要操作系统从外存将页面load到内存。此时内存中没有空闲的页，必须要进行淘汰，即页面置换算法。常见的包括以下几种：

1. OPT 页面置换算法（最佳页面置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法**无法实现**。一般作为衡量其他置换算法的方法。
2. FIFO（First In First Out） 页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
3. LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法） ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
4. LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。

### Linux常见操作命令

目录相关：cd（目录切换）、mkdir（新建目录）、ls（显示目录）、pwd（当前绝对路径）
文件相关：rm（删除）、mv（移动）、cp（拷贝）、touch（新建）
修改权限：chmod（1=执行，2=写，4=读）
其他：ps aux（查看当前系统进程）、grep（搜索）、kill（杀死进程）

## 网络

### 描述一次Http请求

[一次Http请求](https://segmentfault.com/a/1190000006879700)

- DNS解析
  根据域名查询对应的IP地址，涉及到DNS缓存（常用的:浏览器缓存>路由器缓存>服务器缓存）,DNS负载均衡，CDN。
- 建立TCP连接
  三次握手确认连接建立
- 发送HTTP请求
  客户端组装报文并发送
- 服务器处理并返回HTTP报文
  后端代码对请求进行相应处理，并返回数据
- 浏览器解析渲染页面
  返回的报文单纯是字符串则直接输出（例如json）如果是HTML页面，浏览器还会进行渲染

### Session与Cookie

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

### GET和POST

1. get是从服务器上获取数据，post是向服务器传送数据。
2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
3. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。
4. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。

### http状态码

12345法则

- 1** 消息 100 客户端应当继续发送请求。
- 2** 成功 200 成功
- 3** 重定向 301 永久重定向，例如http定向到https 302 临时重定向，例如js跳转
- 4** 请求错误 403 forbidden 拒绝请求。 404 not found 找不到请求的网页。
- 5** 服务器错误 500 Internal Server Error 服务器内部错误，例如代码错误

### http版本

- 1.0
**无状态、无连接** HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。
**队头阻塞** HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。

- 1.1
**长连接** HTTP1.1增加了一个Connection字段，通过设置Keep-Alive可以保持HTTP连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求。
**管道化** 基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。
**新的字段** 如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）。

- 2.0
**二进制分帧** HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能。
**多路复用（连接共享）** HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。
**头部压缩** HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。
**服务器推送** 服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。

### 网络模型及常见协议

[四层模型及OSI七层参考模型](https://blog.csdn.net/guoguo527/article/details/52078962)
[三次握手四次挥手](https://www.cnblogs.com/Jessy/p/3535612.html)

五层结构：

1. 应用层 应用进程交互层，基于应用层协议。常见应用层协议：DNS，HTTP，SMTP（邮件）应用层之间通过报文交互。
2. 运输层 两台主机之间的数据传输。以TCP/UDP方式。
3. 网络层 网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。例如IP协议
4. 数据链路层 通常以帧为单位进行数据传输，丢帧的检错和纠错也是在这一层
5. 物理层 以比特为单位传输数据

TCP协议简略快速回忆版：

三次握手 客户端：我要和你通信(syn-sent) 服务端：你的请求已收到，发送确认(syn-rcvd) 客户端：你的确认已收到，连接建立(est)

四次挥手 客户端：我没有东西了，准备关闭(fin-wait) 服务端：你的关闭我收到了，但我还有点东西没传完(close-wait) ……一段时间后…… 服务端：我的东西传完了，可以关闭了(last-ack) 客户端：收到关闭通知，你也可以关闭了(time-wait)

UDP协议：无需建立连接，不需要确认，不可靠，但高效。常用于即时通讯、语音、直播

滑动窗口：TCP使用滑动窗口协议实现流量控制。

## Mysql

### InnoDB

InnoDB是事务性数据库引擎，支持事务和行级锁

### 字符集

字符集是字符的集合，常见的包括：ASCII、GBK、UTF8等。
Mysql数据库一般使用utf8mb4字符集（mysql默认的utf8最大为3字节，而emoji表情、不常见的汉字等字符都是4字节的）

### 索引

MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

- InnoDB和MyISAM的B+Tree：

1. MyISAM：非聚簇索引。检索时先根据key找到对应的data域，data域存储的是实际数据所在的地址，根据地址读取对应的数据
2. InnoDB：聚簇索引。索引文件和数据文件分离。数据文件本身是一个按照B+Tree存储的主索引，每一个叶子结点都直接存储了完整的数据记录。其余索引都是辅助索引，存储的是主键的值而非地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
  
>MyISAM存地址，InnoDB存真实数据，辅助索引结点存主键

- B树和B+树的主要区别

1. B+Tree左闭右合：关键字的搜索采用的是左闭合区间，之所以采用左闭合区间是因为他要最好的去支持自增id，这也是mysql的设计初衷。即，如果id = 1命中，会继续往下查找，直到找到叶子节点中的1。
2. B+Tree只有叶子结点存数据：即只有叶子节点中的关键字数据区才会保存真正的数据内容或者是内容的地址。而在B树种，如果根节点命中，则会直接返回数据。
3. B+Tree叶子节点不会去保存子节点的引用。
4. B+Tree叶子节点是顺序排列的，并且相邻的节点具有顺序引用的关系，叶子节点之间有指针相连接。

### 事务

- 事务的四大特性（ACID）

1. 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性（Consistency）： 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；
3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 数据库优化

数据库优化主要围绕以下几个方向：

1. SQL和索引优化
2. 表结构优化
3. 系统配置
4. 硬件

具体优化方案：
首先是从代码优化，这是最根本的优化方式，找到瓶颈。尤其注意循环中查询
然后从sql语句上优化，explain查看具体的索引。
其他方向可以考虑读写分离。
>主从同步的方式

[全局唯一增长id生成-美团](https://tech.meituan.com/2017/04/21/mt-leaf.html)
[mysql高性能优化规范](https://www.cnblogs.com/huchong/p/10219318.html)

## Redis

Redis是一种单线程内存型数据库，常用来做缓存、分布式锁、消息队列等。支持的数据类型包括：kv、list、hash等

### 单线程设计

Redis基于Reactor模式设计了高性能单线程模型。

1. 使用单线程模型能带来更好的可维护性，方便开发和调试；
2. 使用单线程模型也能并发的处理客户端的请求；
3. Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；

>I/O 多路复用：多个客户端连接共用一个I/O（多个应用程序通过一根网线传输数据）

如果redis的吞吐量不能达到要求，更好的方案是用多个redis服务器，分片存储数据，而不是在同一个redis服务中使用多线程。

多线程redis用于删除操作：同步删除键，异步删除值

### 过期

设置过期时间后，对应的key会在过期时间后失效，但不会立即删除。
删除策略主要包括：

1. 惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。
2. 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

但是删除策略依旧无法保证所有的key都会自动过期，因此Redis有内存淘汰机制。当内存已满时，除非选择“禁止驱逐数据”的模式（这种情况下满内存写入会报错），否则会根据一定策略进行删除。可以参考操作系统的内存管理机制（经典LRU）

### 缓存相关问题

- 缓存穿透

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

解决方案：使用布隆过滤器。

[布隆过滤器](https://www.cnblogs.com/liyulong1982/p/6013002.html)

- 缓存雪崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

解决办法：注意不要把缓存设定到集中某个时间（例如凌晨0点）按时过期。

- 缓存读写策略

1. 旁路缓存模式 写入时先写DB，再删cache（如果先删，可能会在写入完成前被别的客户端读取从而导致写入旧数据）读取时先读cache，读不到再读DB并回写入cache
   缺点：第一次读取必定不在cache（解决：热数据可以提前写入）。写操作频繁时cache删除频繁
2. 读写穿透 读写都在cache，由固定的服务将cache改动同步到DB（很少见）
3. 异步缓存写入 只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新DB（非常适合一些数据经常变化又对数据一致性要求没那么高的场景：例如微博点赞量，网页访问量，每次cache自动+1，固定时间取出写入DB存储）

## Kafka

## 常见算法题

### 两个栈实现队列

入队：直接入栈stack1；出队：如果stack2不为空，则直接弹出stack2栈顶，否则将stack1全部出栈并入栈stack2，然后pop栈顶。

### 两个队列实现栈

入栈：直接进入非空的那个队列；出栈：非空队列依次出队并入队空队列，直到最后一个元素，则弹出。

### 寻找链表某个特殊节点

创建两个指针，第二个和第一个之间相距x步，当第一个指针走到表尾，则输出第二个指针。

## 一些面试总结

[Java Guide](https://snailclimb.gitee.io/javaguide/)
[各大公司Java后端开发面试题总结](https://blog.csdn.net/sinat_35512245/article/details/59056120)
