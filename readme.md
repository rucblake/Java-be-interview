# 学习

## 语言

### 字符串

String、StringBuffer与StringBuilder

### 集合

#### ArrayList

ArrayList是一个动态数组，容量能够自动增长。ArrayList**不是线程安全**的，线程安全的AL可以通过`Collections.synchronizedList(List l)`获取
支持序列化`write/readObj()`、支持下标`get()`访问、支持克隆

ArrayList包含两个私有属性：elementData和size，分别存储当前包含的元素和元素数量。无参数创建时默认大小为10
插入新元素时，size+1，如果size超过当前数组大小，则动态扩容`ensureCapacity`。申请一个新的数组，大小为1.5倍，并将旧的数组复制到新的数组。旧的数组在调用`Arrays.copyOf()`进行复制前，会通过`Object oldData[] = elementData;`进行一次引用，保证copy过程的安全。拷贝使用`System.arraycopy()`方法，底层使用C语言实现，效率更高。

#### LinkedList

LinkedList是一个双向链表，对于插入和删除频繁的list，使用LinkedList会优于ArrayList。LinkedList**不是线程安全**的
LinkedList包括三个成员变量：头结点`first`，尾结点`last`，容量`size`。每一个结点也都是双向结点，包括`prev`和`next`。链表的插入删除时间复杂度都为O(1)。下标查询方式为从头/从尾遍历。占用内存更大。

#### HashMap

[HashMap详解](https://blog.csdn.net/woshimaxiao1/article/details/83661464)

HashMap基于数组+链表实现，解决哈希冲突的方法是链地址法。HashMap不是线程安全的。
HashMap的Entry数据结构包括四个属性：key，value，next（存储下一个entry），hash（key计算出的哈希值）。
哈希表本身还包括几个重要属性：size（实际存储的kv数量），threshold（阈值，默认16），loadFactor（负载因子，默认0.75），modCount（哈希表被改变的次数）

扩容操作：当插入元素后size大于阈值的时候，新建一个大小为双倍的数组，并将目前已有的数据都拷贝过去
插入操作：根据key计算出哈希code：h，然后index = h&(length-1)。因为哈希表的length固定为2的n次幂，因此-1后高位为0，其余为1，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)
查询操作：根据key获取具体的index，找到对应数组下标，判断是否是链表，如果是链表则遍历，直到找到**hash值相同的并且key**相同的entry，然后输出。

JDK1.8对HashMap进行了优化，把链表换成了红黑树，能够保证更快的检索速度。（链表节点大于等于8且数组长度大于等于64）

如果需要线程安全的HashMap，可以使用ConcurrentHashMap（Hashtable也是线程安全的，但是是遗留类，不建议使用）ConcurrentHashMap内部封装了多个HashMap，可以分段加锁而不影响效率。
>不建议使用Hashtable是因为：synchronized会造成线程饥饿和死锁，且进行遍历时其他线程也能对其进行put等操作

### IO

javaIO框架把不同的输入、输出源抽象称作stream，即“流”。通过抽象，代码能够统一对流进行数据处理，而不必关心具体的输入输出形式。

#### 字节流与字符流

底层设备永远是通过字节流传输。字符流是对字节流的包装，直接接收字符串，方便处理。

#### AIO/BIO/NIO

- BIO（同步阻塞I/O模式）
  数据的读取写入必须阻塞在一个线程内等待其完成。
  直到水烧开以前不做任何别的事。

- NIO（同步非阻塞I/O模型）
  使用一个线程去轮询IO操作，发现改变后及时处理。
  有一个线程单独监控水的状态，一旦烧开则通知

- AIO（异步非阻塞I/O模型）
  异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。
  每一个水壶都装了开关，水烧开了开关自动通知
  
### 多线程

多线程的好处:

1. 提高CPU的利用率。从磁盘上读取文件的时候，大多数的CPU时间都会花费在等待磁盘来读取数据。在这个时候CPU是相当空闲的。在这个时候它可以干点别的事情。通过改变操作的顺序，CPU可以得到更好的利用。
2. 防止阻塞主线程,提高吞吐量。使用线程可以把占据时间长的程序中的任务放到后台去处理
3. 程序的运行效率可能会提高，提升程序的响应速度。

```java
Thread t = new Thread();
t.start()
```

通过extends实现自己的线程，通过`start()`方法启动线程，会执行线程内部实现的`run()`方法
线程执行是无序不等待的，可以通过`join()`方法等待线程执行完毕
通过`synchronized`获取锁
通过`this.wait()`等待，必须在`synchronized`内部才能调用

#### synchronized

#### volatile

[volatile详解](https://www.cnblogs.com/wangwudi/p/12303772.html)
多线程执行时，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。而将工作内存的变量写回主内存的时机则不确定。对于volatile修饰的变量，java虚拟机有特殊的约定：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。

volatile针对变量，而Synchronized针对对象和类

#### 乐观锁和悲观锁

乐观锁：读的时候允许写锁后入，导致读的数据可能是不一致的（例如获取锁以后，读取某x的值，但是此时另一个线程获取了写锁，改写了x的值，此时x的值已被更改）
悲观锁：读的过程不允许写，必须等待。
乐观锁的并发效率更高，但是需要有检测机制，检查乐观读锁后是否有新的写锁，如果有，则需要加悲观锁进行读（避免再次被修改）

### JVM内存模型

### 垃圾回收机制

### Maven

## 数据结构

### 二叉树

树是一种常见的数据结构，所有结点的度均不超过2的有序树为二叉树。二叉树是一种最简单且最重要的树，所有的树都能转化为二叉树。
[二叉树介绍](https://www.jianshu.com/p/bf73c8d50dc2)

#### 二叉树的遍历

通常使用递归调用的方法进行二叉树的遍历，并根据递归的输出顺序，可以简单地分为：前序遍历，中序遍历，后序遍历。

- 前序遍历
从二叉树的根结点出发，当第一次到达结点时就输出结点数据。按照先左后右的顺序，只要能向左前进，就一直向左，否则返回上层，向右前进，而后继续尝试向左。如果右侧也为叶子结点，则返回上层。
技巧：按照遍历顺序输出
遍历代码：

```java
/*前序遍历*/
void PreOrderTraverse(BiTree T)
{
    if(T == NULL) {
        return;
    }
    System.out.println("%c", T.data);  /*先输出*/
    PreOrderTraverse(T.lchild);    /*再遍历左*/
    PreOrderTraverse(T.rchild);    /*最后遍历右*/
}
```

>对于二叉树来说，前序遍历即深度优先搜索

- 中序遍历
从二叉树的根结点出发，当第二次到达结点时就输出结点数据。按照先左后右的顺序，先向左前进，如果前进后为空（即原结点为叶子结点）则返回原结点，此时第二次访问，输出。后续继续向右前进
技巧：对于每一个子树，输出顺序均为左中右
遍历代码：

```java
/*中序遍历*/
void InOrderTraverse(BiTree T)
{
    if(T == NULL) {
        return;
    }
    InOrderTraverse(T.lchild);    /*先遍历左*/
    System.out.println("%c", T.data);  /*再输出*/
    InOrderTraverse(T.rchild);    /*最后遍历右*/
}
```

- 后序遍历
从二叉树的根结点出发，当第三次到达结点时就输出结点数据。按照先左后右的顺序，先向左前进，如果前进后为空（即原结点为叶子结点）则返回原结点，再向右侧出发，如果前进后为空，则返回原结点，此时第三次访问，输出。
技巧：对于每一个子树，输出顺序均为左右中
遍历代码：

```java
/*后序遍历*/
void PostOrderTraverse(BiTree T)
{
    if(T == NULL) {
        return;
    }
    PostOrderTraverse(T.lchild);    /*先遍历左*/
    PostOrderTraverse(T.rchild);    /*后遍历右*/
    System.out.println("%c", T.data);  /*最后输出*/
}
```

- **重点考点：根据前序遍历/后序遍历和中序遍历顺序，确定一颗二叉树**
首先根据前序/后续遍历获取根节点：前序遍历的第一个结点和后序遍历的最后一个结点，都必定是根节点。
然后根据根结点，从中序遍历中获取左子树和右子树：位于中序遍历中根结点前的均为左子树，根结点后的均为右子树。
重复上述过程，继续对子树进行分析，即可得到结果

- 层次遍历
从二叉树的根结点出发，按照从上到下，从左到右的方式依次进行输出，为层次遍历

>对于二叉树来说，层次遍历即为广度优先搜索

### 红黑树

[红黑树介绍](https://zhuanlan.zhihu.com/p/79980618)
[红黑树介绍](https://tech.meituan.com/2016/12/02/redblack-tree.html)

红黑树是一种平衡二叉查找树。二叉查找树是一种左子节点的值比父节点的值要小，右节点的值要比父节点的值大的二叉树。

红黑树定义如下：

1. 任何一个节点都有颜色，黑色或者红色。
2. 根节点是黑色的。
3. 父子节点之间不能出现两个连续的红节点。
4. 任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。
5. 空节点被认为是黑色的。

如果父节点和新节点为红色，则按照以下规则进行修复：
左左：提绳法，提起父节点并变色
左右：旋转新节点，然后复用左左
右右：提起父节点并变色
右左：旋转新节点，然后复用右右

## 操作系统

### 进程的状态和转换

[操作系统之进程的状态和转换详解](https://blog.csdn.net/qwe6112071/article/details/70473905)

### 进程 vs 线程

和多线程相比，多进程的缺点在于：
创建进程比创建线程开销大，尤其是在Windows系统上；
进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：
多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

### Linux常见操作命令

## 网络

### 描述一次Http请求

### Session与Cookie

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

### GET和POST

1. get是从服务器上获取数据，post是向服务器传送数据。
2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
3. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。
4. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。

### http状态码

12345法则

- 1** 消息 100 客户端应当继续发送请求。
- 2** 成功 200 成功
- 3** 重定向 301 永久重定向，例如http定向到https 302 临时重定向，例如js跳转
- 4** 请求错误 403 forbidden 拒绝请求。 404 not found 找不到请求的网页。
- 5** 服务器错误 500 Internal Server Error 服务器内部错误，例如代码错误

### http版本

- 1.0
**无状态、无连接** HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。
**队头阻塞** HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。

- 1.1
**长连接** HTTP1.1增加了一个Connection字段，通过设置Keep-Alive可以保持HTTP连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求。
**管道化** 基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。
**新的字段** 如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）。

- 2.0
**二进制分帧** HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能。
**多路复用（连接共享）** HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。
**头部压缩** HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。
**服务器推送** 服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。

### TCP/IP

[四层模型及OSI七层参考模型](https://blog.csdn.net/guoguo527/article/details/52078962)
[三次握手四次挥手](https://www.cnblogs.com/Jessy/p/3535612.html)

简略快速回忆版：

三次握手 客户端：我要和你通信(syn-sent) 服务端：你的请求已收到，发送确认(syn-rcvd) 客户端：你的确认已收到，连接建立(est)

四次挥手 客户端：我没有东西了，准备关闭(fin-wait) 服务端：你的关闭我收到了，但我还有点东西没传完(close-wait) ……一段时间后…… 服务端：我的东西传完了，可以关闭了(last-ack) 客户端：收到关闭通知，你也可以关闭了(time-wait)

## Mysql

### 数据库优化

数据库优化主要围绕以下几个方向：

1. SQL和索引优化
2. 表结构优化
3. 系统配置
4. 硬件

具体优化方案：
首先是从代码优化，这是最根本的优化方式，找到瓶颈。尤其注意循环中查询
然后从sql语句上优化，explain查看具体的索引。
其他方向可以考虑读写分离。
>主从同步的方式

## Redis

## Kafka

## 常见算法题

### 两个栈实现队列

入队：直接入栈stack1；出队：如果stack2不为空，则直接弹出stack2栈顶，否则将stack1全部出栈并入栈stack2，然后pop栈顶。

### 两个队列实现栈

入栈：直接进入非空的那个队列；出栈：非空队列依次出队并入队空队列，直到最后一个元素，则弹出。

### 寻找链表某个特殊节点

创建两个指针，第二个和第一个之间相距x步，当第一个指针走到表尾，则输出第二个指针。

## 一些面试总结

[各大公司Java后端开发面试题总结](https://blog.csdn.net/sinat_35512245/article/details/59056120)
